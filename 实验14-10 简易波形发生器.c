#include <AT89X52.h>
#include <math.h>




#define ADDR1 0x2c //MAX5820LEUA

sbit key_sin=P1^0;
sbit key_tran=P1^2;
sbit key_tooth=P1^4;

sbit SCL = P2 ^ 0;
sbit SDA = P2 ^ 1;

unsigned char code sin[256]=     //正弦表
	{
	0x80,0x83,0x86,0x89,0x8d,0x90,0x93,0x96,0x99,0x9c,0x9f,0xa2,0xa5,0xa8,0xab,0xae,0xb1,0xb4,0xb7,0xba,0xbc,0xbf,0xc2,0xc5, 
	0xc7,0xca,0xcc,0xcf,0xd1,0xd4,0xd6,0xd8,0xda,0xdd,0xdf,0xe1,0xe3,0xe5,0xe7,0xe9,0xea,0xec,0xee,0xef,0xf1,0xf2,0xf4,0xf5, 
	0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfd,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xfd, 
	0xfd,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,0xf6,0xf5,0xf4,0xf2,0xf1,0xef,0xee,0xec,0xea,0xe9,0xe7,0xe5,0xe3,0xe1,0xde,0xdd,0xda, 
	0xd8,0xd6,0xd4,0xd1,0xcf,0xcc,0xca,0xc7,0xc5,0xc2,0xbf,0xbc,0xba,0xb7,0xb4,0xb1,0xae,0xab,0xa8,0xa5,0xa2,0x9f,0x9c,0x99,
	0x96,0x93,0x90,0x8d,0x89,0x86,0x83,0x80,0x80,0x7c,0x79,0x76,0x72,0x6f,0x6c,0x69,0x66,0x63,0x60,0x5d,0x5a,0x57,0x55,0x51, 
	0x4e,0x4c,0x48,0x45,0x43,0x40,0x3d,0x3a,0x38,0x35,0x33,0x30,0x2e,0x2b,0x29,0x27,0x25,0x22,0x20,0x1e,0x1c,0x1a,0x18,0x16, 
	0x15,0x13,0x11,0x10,0x0e,0x0d,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0d,0x0e,0x10,0x11,0x13,0x15, 
	0x16,0x18,0x1a,0x1c,0x1e,0x20,0x22,0x25,0x27,0x29,0x2b,0x2e,0x30,0x33,0x35,0x38,0x3a,0x3d,0x40,0x43,0x45,0x48,0x4c,0x4e, 
	0x51,0x55,0x57,0x5a,0x5d,0x60,0x63,0x66,0x69,0x6c,0x6f,0x72,0x76,0x79,0x7c,0x80
	};

bit write_addr(unsigned char,bit);//第一个参数表示地址，第二个参数表示 读：1 写：0
bit write_data(unsigned char);//第一个参数表示数据，第二个参数表示 命令字
void stop();
void Delay(unsigned int);

I2C_Delay(unsigned int I2C_VALUE)
{	
	while ( --I2C_VALUE!= 0 );
}
/*
函数：I2C_Init()
功能：I2C 总线初始化，使总线处于空闲状态
说明：在 main()函数的开始处，通常应当要执行一次本函数
*/
void I2C_Init()
{
	SCL = 1;
	I2C_Delay(5);
	SDA = 1;
	I2C_Delay(5);
}
/*
函数：I2C_Start()
功能：产生I2C 总线的起始状态
说明：
SCL处于高电平期间，当SDA 出现下降沿时启动I2C 总线
不论 SDA 和SCL 处于什么电平状态，本函数总能正确产生起始状态
本函数也可以用来产生重复起始状态
本函数执行后，I2C 总线处于忙状态
*/
void I2C_Start()
{
	SDA = 1;
	I2C_Delay(5);
	SCL = 1;
	I2C_Delay(5);
	SDA = 0;
	I2C_Delay(5);
	SCL = 0;
	I2C_Delay(5);

}
/*
函数：I2C_Write()
功能：向I2C 总线写1 个字节的数据
参数：
dat：要写到总线上的数据
*/
void I2C_Write(char dat)
{
	unsigned char t = 8;
	do
	{
		SDA = (bit)(dat & 0x80);
		dat <<= 1;
		SCL = 1;
		I2C_Delay(5);
		SCL = 0;
		I2C_Delay(5);
	} while ( --t != 0 );
}

bit I2C_GetAck()
{
	bit ack;
	SDA = 1;
	I2C_Delay(5);
	SCL = 1;
	I2C_Delay(5);
	ack = SDA;
	SCL = 0;
	I2C_Delay(5);
	return ack;
}

void I2C_Stop()
{
	unsigned int t = 10;
	SDA = 0;
	I2C_Delay(5);
	SCL = 1;
	I2C_Delay(5);
	SDA = 1;
	I2C_Delay(5);
	while ( --t != 0 ); //在下一次产生Start 之前，要加一定的延时
}

void Delay(unsigned int I2C_Delay_t)
{	
	while ( --I2C_Delay_t!= 0 );
}

bit write_addr(unsigned char addr,bit mod)
{
	unsigned char address;
	address=addr<<1;
	if(mod)
		address++;
	I2C_Start();
	I2C_Write(address);
	Delay(10);
		
	if(I2C_GetAck())
		return 1;

	return 0;

}

bit write_data(unsigned char dat)
{

	I2C_Write(dat);
	if(I2C_GetAck())
		return 1;
	return 0;

}

void stop()
{
	I2C_Stop();
	I2C_Init();
}

void main(void)
{
	unsigned char i;
	loop:
	I2C_Init();
	while(1)
	{
		if(key_sin==0)	//产生正弦波
		{
			while(1)
			{
				for(i=192;i<255;i++)
				{
					write_addr(ADDR1,0);
					write_data(0);
					write_data(sin[i]);
					stop();
					if(!(key_tran!=0&&key_tooth!=0))
						goto loop;
				}
		
				for(i=0;i<192;i++)
				{
					write_addr(ADDR1,0);
					write_data(0);
					write_data(sin[i]);
					stop();
					if(!(key_tran!=0&&key_tooth!=0))
						goto loop;
				}
			}
		}
		if(key_tran==0)	//产生三角波
		{
			while(1)
			{
				 for(i=0;i<255;i++)
				{
					write_addr(ADDR1,0);
					write_data(0);
					write_data(i);
					stop();
					if(!(key_sin!=0&&key_tooth!=0))
						goto loop;
				} 
				for(;i>0;i--)
				{
					write_addr(ADDR1,0);
					write_data(0);
					write_data(i);
					stop();
					if(!(key_sin!=0&&key_tooth!=0))
				 		goto loop;
				}
			}
		}
		if(key_tooth==0)  //产生锯齿波
		{
			while(1)
			{
				 for(i=0;i<255;i++)
				{
					write_addr(ADDR1,0);
					write_data(0);
					write_data(i);
					stop();
					if(!(key_tran!=0&&key_sin!=0))
						goto loop;
				} 
			}
		}	
	}
}

